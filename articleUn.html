<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> </title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
</head>
</head>

<body>

    <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Baraka</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="./index.html">Pésentation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link " href="./portfolio.html">Potfolio</a>
                    </li>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link " href="./projet.html">Projets académiques</a>
                    </li>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="">Estimation d'erreur</a>
                    </li>
            </div>
        </div>
    </nav>
    <div class="container ">
        <h3 class="d-flex justify-content-center">
            Presentation du cours
        </h3>
        <div>
            <p class="fs-5">
                Dans cette section je vais partager en détail tout ce que nous avons exploré et accompli au fil des
                différentes séances de notre cours sur l'estimation d'erreur et l'adaptation de maillage.

                Vous découvrirez les concepts clés que nous avons abordés, les exercices que nous avons pratiqués et les
                découvertes passionnantes que nous avons faites ensemble.

                Voyons les détails de chaque leçon pour ainsi comprendre les principes de l'estimation d'erreur et de
                l'adaptation de maillage de manière accessible.
            </p>
            <div class="d-flex justify-content-center">
                <a class="btn btn-primary " href="./pdf/cours_adapopt_bm.pdf">
                    Voir le cours
                </a>
            </div>
        </div>
        <div class="m-2">
            <div class="accordion" id="accordionExample">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                            Seance 1
                        </button>
                    </h2>
                    <div id="collapseOne" class="accordion-collapse collapse show" data-bs-parent="#accordionExample">
                        <div class="accordion-body">
                            <code>

                                -installer anaconda / spyder ou jupyter notebook <br>
                                -installer freefem<br>
                            </code>
                            Voir Annexe B du POLY.pdf pour rappel des definitions <br>
                            V=(v1, v2) <br>
                            u,t + <V , grad u> - nu div( grad u) = -lambda u + f <br>
                                u,t + v1 u,x + v2 u,y - nu ( u,xx + u,yy ) = -lambda u + f <br>
                                ChatGPT generer un code python pour resoudre cette equation dans un domaine
                                rectangulaire <br>
                                avec f(t,s) = Tc exp(-k d(s,sc)2) avec d(s,sc)2 = (s1 - sc1)2 + (s2 - sc2)2
                                passage 1D: <br>
                                u,t + v1 u,x - nu u,xx = -lambda u + f
                                condition initiale u(t=0,x)=u0(x)
                                conditions aux limites: u(t,x=0)=2, u,x(t,x=L)=1
                                Dirichlet non homogene a gauche et Neuman non homogene a droite. <br>
                                A FAIRE SEMAINE 1 <br>
                                Faire un code Python pour resoudre l'equation differentielle suivante: <br>
                                u,t = - lambda u, u(0)=1, lambda = 1
                                en utilisant un schema d'Euler explicit et comparer avec la solution exacte: <br>
                                uex(t)= u0
                                exp(-lambda t)
                                Pour Dt = 1s, tracer les solution exacte et numerique et l'erreur en temps sur 1 minute.
                                Tracer la courbe de l'erreur L2 en fonction du pas de temps.
                                LIRE JUSQU'A 4/ poly_adapopt_bm.pdf
                        </div>
                    </div>
                </div>
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                            Seance 2
                        </button>
                    </h2>
                    <div id="collapseTwo" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                        <div class="accordion-body">
                            Soit:<br>
                            -comprendre le code Python adrs.py pour resoudre:<br>
                            -pour u(s)=uex(s) = exp(-10*(s-L/2)**2), trouver f, la porter dans le code<br>
                            u,t + v u,s - nu u,ss + lambda u = f(s)<br>
                            v=1, nu=0.01, lambda=1 L=1<br>
                            -Implemente f(s) dans le code et verifier si on retrouve uex(s) ?<br>
                            maillage uniforme en N points = discretisation de [0,L] en (N-1) intervalles s_i = (i-1)*h
                            avec h=L/(N-1)<br>
                            -s'assurer de la convergence vers la solution stationnaire pour un maillage de 100
                            points<br>
                            -tracer la convergence ||un+1 - un||_L2 normalisee : on a la solution stationnaire<br>
                            -calculer apres convergence les normes L2 et H1 de (u-uexact) pour differents maillages,
                            partant de 3 points.<br>
                            -tracer l'erreur L2 et H1 en fonction de h=dx pour ces cinq maillages<br>
                            -Placer les images cote a cote.<br>
                            Pour le schema numerique:<br>
                            Identifier ou sont les elements suivants dans le code vu en seance<br>
                            -decentrage = centre + viscosite numerique (chap 12)<br>
                            -condition de stabilite CFL (chap 10)<br>
                            -quelle condition en sortie est implementee actuellement ?<br>
                            u1(n)=u1(n-1)-ux(xmax-x(n-1))+uxx(n-1)(xmax-x(n-1))**2/2<br>
                            -implementer u,s(s=L)=0<br>
                            -faire exo 4 -> interpolation Ph (lineaire)<br>
                            -regarder thm 18.1.3 (relation entre l'erreur d'interpolation et la derivee seconde)<br>
                            -Evaluer en discret les normes des differences du poly sur les differents maillages (L2
                            difference solutions et derivees approchee et exacte, L2 difference solutions exacte et son
                            interpole P1, derivee seconde).
                            Optionnel:<br>
                            Exporter dans un fichier la norme L2, la norme H1, la semi-norme H2 pour chaque dx <br>
                            Utiliser un algorithme d'optimisation pour identifier (C,k) et trouver M.<br>
                            Poly 2.3.1 (c'est un probleme de regression)<br>
                            quel est l'ordre en espace de ce code ?<br>
                            Apres avoir trouve x_opt=(C,k) pour chaque probleme de moindres carres:<br>
                            -Visualiser les courbes : Q1 vs. C h^(k+1) et Q2 vs. C h^k
                            |u − uh|{0,2} / |u|{2,2} < ? h**? </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                                Seance 3
                            </button>
                        </h2>
                        <div id="collapseThree" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                -lire 18.4.2 <br>

                                -Faire les etapes de 5/ <br>

                                -identifier la definition de la metrique dans le code (quelle loi est en place ?) <br>

                                -implementer la loi 3 <br>

                                -tracer NX(err) pour err=0.04, 0.02, 0.01, 0.005, 0.0025 <br>

                                -comment evolue NX en fonction de err ? <br>

                                -Quels sont les criteres d'arret pour l'iteration d'adaptation.<br>

                                Introduire un critere mixte portant sur le nombre de points de maillage et l'erreur L2:
                                ne pas s'arreter <br>

                                tant que les 2 ne sont pas realises.<br>

                                -Identifier la contraction dans ce code<br>

                                -Restructurer le code en introduisant 3 fonctions (adrs, metric, mesh) <br>
                            </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                data-bs-target="#collapsefour" aria-expanded="false" aria-controls="collapsefour">
                                Seance 4
                            </button>
                        </h2>
                        <div id="collapsefour" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                -lire 18.4.2 <br>

                                -Faire les etapes de 5/ <br>

                                -identifier la definition de la metrique dans le code (quelle loi est en place ?) <br>

                                -implementer la loi 3 <br>

                                -tracer NX(err) pour err=0.04, 0.02, 0.01, 0.005, 0.0025 <br>

                                -comment evolue NX en fonction de err ? <br>

                                -Quels sont les criteres d'arret pour l'iteration d'adaptation.<br>

                                Introduire un critere mixte portant sur le nombre de points de maillage et l'erreur L2:
                                ne pas s'arreter <br>

                                tant que les 2 ne sont pas realises.<br>

                                -Identifier la contraction dans ce code<br>

                                -Restructurer le code en introduisant 3 fonctions (adrs, metric, mesh) <br>
                            </div>
                        </div>
                    </div>

                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                data-bs-target="#collapsefive" aria-expanded="false" aria-controls="collapsefive">
                                Seance 5
                            </button>
                        </h2>
                        <div id="collapsefive" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                PRISE EN MAIN DE FREEFEM



                                -freefem: - Quelle est l'equation resolue dans adapsteady.edp ?

                                Faire evoluer le script pour resoudre l'equation de Stokes et

                                ADRS (pour le transport d'un scalaire passif : temperature)

                                couplees dans un domaine carre, puis en forme de U.



                                Utiliser l'algorithme d'adaptation de maillage stationnaire pour trouver la

                                solution convergee en maillage pour des niveaux d'erreur de epsilon = 0.01 et 0.005.



                                Decrire le script et visualiser les solutions (vitesse, temperature) et les maillages.

                                <hr>
                                <strong>
                                    Suite
                                </strong>
                                Utilisation d'integration de Lebesgues vs. Riemann <br>

                                f(x)=exp(-a*(x-L/3)*2)-2exp(-a(x-2L/3)**2), a=100, L=1

                                integrer en Riemann cette fonction
                                adapter le pas d'integration (Lebesgues) <br>


                                faire la meme chose en 2d avec Monte Carlo
                            </div>
                        </div>
                    </div>

                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                data-bs-target="#collapsesix" aria-expanded="false" aria-controls="collapsesix">
                                Seance 6 : ex 9
                            </button>
                        </h2>
                        <div id="collapsesix" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                Optimisation en utilisant la linearite de l'equation d'etat par rapport aux controles.
                                <br>



                                ADRS avec N controles sources:<br>



                                Tracer la surface J(x1,x2,....) en echantillonnant les deux premiers controles (les
                                autres fixes). <br>



                                Si l'adaptation de maillage est utilisee lors des calcul des solutions et seconds
                                membres elementaires,

                                ces quantites ne seront pas disponibles sur le meme maillage. <br>

                                Comment calculer alors numeriquement les expressions Aij et Bi ?



                                Quelle doit etre la precision de l'integration numerique approchee (Aij, Bi)

                                pour ne pas introduire d'erreur supplementaire a ce niveau ? voir poly_cours



                                Modifier le code fourni pour repondre aux questions precedentes (en introduisant
                                l'adaptation

                                et l'interpolation entre maillages).<br>



                                comparer le controle optimal obtenu avec la solution sur maillage fixe (assez fin pour
                                servir de

                                reference).<br>



                                ///////////////////////////////////////////////////

                                ADRS (xcible = (1,2,3,4) --> udes=u(xcible) --> J(xcible)= 1/2 ||u(xcible)-udes||^2<br>
                                ADRS (x) --> u(x) --> J(x)= 1/2 ||u(x)-udes||^2 <br>
                                Utiliser un minimiseur python pour trouver xopt <br>
                                Utiliser la linéarité de l'équation ADRS pour simplifier les calculs (voir plus bas)
                                <br>


                                ////////////////////////////////////////////////////



                                Algorithm <br>



                                Probleme inverse <br>

                                define Xopt=(1,2,3,4) in R^4 <br>

                                define udes=u(Xopt) par ex<br>



                                J(x) = min_x 1/2 ||u(x)-udes||^2 -> X* = Xopt ?<br>



                                X such that Grad_x J(X) = 0 <br>





                                Refinement loop Th2<br>



                                find U0 <br>

                                find U1, U2, U3, U4 <- U(ei) Calculate : Grad_x J(u(x))=Ax-b=0 (to show) Aij=<ui,uj>L2
                                    <br>

                                    bi=<ui,(u(x)-udes)>L2 <br>



                                        Invert A X* = b with x=(alpha_1,...,alpha_4) <br>



                                        check if u(X)=udes? calculating J(Xopt) = ||u(X)-udes||^2 and if Xopt = X* <br>

                                        //////////////////////////////////////////////////////



                                        Introduce a refinement loop and see the impact on the convergence to Xopt (plot
                                        each component of X*(h)). <br>

                                        Plot J(X(h)) and error=||X(h) - Xopt|| <br>





                                        Now look for udes=1 (we do not know Xopt) and see how close you can get with
                                        this control ? <br>

                                        Plot J(X(h)) and the evolution of each component of X(h)
                            </div>
                        </div>
                    </div>

                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                                data-bs-target="#collapseseven" aria-expanded="false" aria-controls="collapseseven">
                                Seance 7
                            </button>
                        </h2>
                        <div id="collapseseven" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                24/10 examen ecrit + releve de compteur sur les sites web <br>









                                OPTIONNEL: <br>









                                On considere u,t=sin(2 pi t), u(0)=a et J(a)=(1/2) u^2(t=1,a) <br>



                                -Calculer dJ/da = u u,a <br>

                                -Ecrire un petit programme pour resoudre l'equation par Euler explicit <br>

                                -Calculer dJ/da par differences finies et variables complexes <br>

                                -Comparer au gradient exact <br>



                                u(t)=-1/(2 pi) (cos(2 pi t)-1)+a

                                u,a=1

                                dJ/da = u u,a <br>







                                Ex 10.2 <br>



                                -Quelle est la complexite en terme de stockage de l'information pour

                                pouvoir calculer l'adjoint par integration retrograde ? <br>



                                -Refaire les calculs avec l' equation nonlineaire suivante: <br>

                                ut + uu,s - nu u,ss = lambda u + f(x): <br>

                                Quelles nouvelles consequences sur le stockage (besoin d'utilisation des etats
                                intermediaires) ? <br>



                                Le programme advdiffadapadj propose une implementation de l'ensemble de cette
                                discussion. <br>



                                Quelle est la fonctionnelle consideree ? <br>



                                Quelle est l'approximation aux differences finies utilisee ? <br>



                                comparer le gradient par differences finies et l'adjoint: illustrer les deux gradients
                                sur une meme figure. <br>



                                Que se passe-t-il au niveau du maillage quand l'adjoint est pour une fonctionnelle
                                donnee par la norme H^1. <br>









                                Utiliser ce script pour generer une BD d'apprentissage contenant pour chaque scenario:

                                (largeur entree, vitesse entree, viscosite, Temperature entree, coupe a 1/3 domaine,
                                coupe a 2/3 domaine)

                                les coupes seront en 10 points et releveront les valeurs des champs de vitesse et
                                temperature : <br>

                                30 valeurs (vecteur vitesse + champ temperature)x10 points <br>



                                Pour plus de facilite, commencer avec une seule entree. <br>



                                Apprendre cette BD, et donner l'erreur en crossfold avec

                                un modele lineaire donne dans le scipt python skl_... pour deux problemes: <br>



                                R4 -- > R30 : connaissant les parametres de fonctionnement (largeur entree, vittesse
                                entree, viscosite, Temperature entree) <br>

                                trouver les champs sur la coupe en 2/3 <br>



                                R30 -- > R30: connaissant le champs a 1/3 trouver le champ a 2/3 du domaine. <br>



                                Le premier probleme permet d'utiliser la ML pour trouver le champ pour de nouveaux
                                points de fonctionnement.



                                Le second permet de trouver apres une mesure non intrusive, le champs dans une partie
                                non visible du domaine. <br>





                                Le script skl... permet de lire des fichiers csv, de visualiser les donnees, et

                                d'apprendre la base de donnees pour identifier le modele lineaire adapte,

                                en utilisant differentes regularisations (voir exo 39 poly cours_optim_bm.pdf) <br>











                                Optimisation en utilisant la linearite de l'equation d'etat par rapport aux
                                controles. <br>



                                Un exemple d'implementation est donnee en Freefem (pbinv2d_ADR.edp) pour ADRS

                                avec N controles sources:<br>



                                Tracer la surface J(x1,x2,....) en echantillonnant les deux premiers controles (les
                                autres fixes). <br>



                                Si l'adaptation de maillage est utilisee lors des calcul des

                                solutions et seconds membres elementaires, ces quantites ne seront pas disponibles

                                sur le meme maillage. <br>

                                Comment calculer alors numeriquement les expressions Aij et Bi ? <br>



                                Quelle doit etre la precision de l'integration numerique approchee (Aij, Bi)

                                pour ne pas introduire d'erreur supplementaire a ce niveau ? voir poly_cours



                                Modifier le code fourni pour repondre aux questions precedentes (en introduisant
                                l'adaptation

                                et l'interpolation entre maillages).<br>



                                comparer le controle optimal obtenu avec la solution sur maillage fixe (assez fin pour
                                servir de reference).<br>















                                C++ <br>




                                1/advect.cpp est un petit code simple en C++ pour la solution de l'equation de
                                transport. <br>

                                Comprendre le code. Compiler (g++ -O advect.cpp -o advect.exe) / executer et visualiser
                                le resultat avec<br>

                                gnuplot. <br>



                                2/adap.cpp est une version C++ de notre travail pour la solution de l'equation ADRS et
                                l'adaptation de maillage par controle de metrique. <br>

                                Compilation: g++ -O adap.cpp -o adap.exe <br>

                                La solution est dans results.dat et peut etre visualise avec gnuplot. <br>



                                Ce sont des codes statiques et auto-suffisants. Il y a un exemple d'insertion de
                                librairie externe en statique <br>

                                dans advect.cpp <br>





                                decouper adap.cpp programme en routines/librairies avec un programme principal. <br>


                                creer un makefile <br>


                                completer cet ensemble avec la partie optimisation qu'on a vu en Fortran et le calcul
                                d'adjoint. <br>


                                Ce travail vous preparera au cours C++ a suivre. <br>









                                exemple sortie gnuplot<br>

                                set title 'TITRE' <br>

                                set xlabel 'x(M)' <br>

                                set ylabel 'u(kg/m3)' <br>

                                plot [0:1][] 1/x w l lw 4 title 'Model',1/x**2 lw 3 title 'Model 2'<br>



                                plot 1:(log10($2)) w l <br>

                                plot [0:1][] 1/x**2 w linespoints lw 3 <br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


        </div>
        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
            integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
            crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
            integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
            crossorigin="anonymous"></script>
</body>

</html>